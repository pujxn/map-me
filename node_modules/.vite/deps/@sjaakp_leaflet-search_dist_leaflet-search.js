// node_modules/@sjaakp/leaflet-search/dist/leaflet-search.js
!function() {
  "use strict";
  !function(t2) {
    if (t2 && "undefined" != typeof window) {
      var e2 = document.createElement("style");
      e2.setAttribute("type", "text/css"), e2.innerHTML = t2, document.head.appendChild(e2);
    }
  }(".geo-search{box-shadow:0 1px 5px rgba(0,0,0,.65)}.geo-search svg{width:1.2em}.geo-search input{transition:width .4s;width:0;padding:2px 0;border:solid #888;border-width:1px 0;outline:0}.geo-search.open input{width:15em;padding:2px 2px;border-width:1px;border-top-left-radius:4px;border-bottom-left-radius:4px}.geo-search button{border:1px solid #888;border-top-right-radius:4px;border-bottom-right-radius:4px;padding:2px 6px}.geo-search button:hover{background-color:#ddd}"), L.geo = { Geocoder: L.Class.extend({ initialize: function(t2, e2) {
    this._map = t2, L.setOptions(this, e2);
  }, constructUrl: function(t2, e2) {
    void 0 === e2 && (e2 = {});
    var n2 = Object.assign({}, this.options, e2), o2 = new URL(t2);
    for (var r2 in n2)
      o2.searchParams.set(r2, n2[r2]);
    return o2;
  }, fetchJson: function(t2) {
    return fetch(t2.href).then(function(t3) {
      return t3.json();
    });
  }, placeMarker: function(t2, e2, n2) {
    this._map.placeMarker(t2, e2, n2);
  }, fire: function(t2) {
    this._map.fire(t2);
  }, suggest: function(t2, e2) {
  }, lookup: function(t2) {
  } }) }, L.geo.Nominatim = L.geo.Geocoder.extend({ url: "https://nominatim.openstreetmap.org/", mark: function(t2) {
    var e2 = L.latLng(t2.lat, t2.lon), n2 = t2.boundingbox, o2 = L.latLngBounds([n2[0], n2[2]], [n2[1], n2[3]]);
    this.placeMarker(e2, o2, t2);
  }, search: function(t2) {
    var e2 = this.constructUrl(this.url + "search", { format: "json", q: t2 });
    return this.fetchJson(e2);
  }, suggest: function(t2, e2) {
    var n2 = this;
    this.search(t2).then(function(t3) {
      e2.innerHTML = t3.reduce(function(t4, e3) {
        return t4 + '<option data-id="' + e3.osm_type.charAt(0).toUpperCase() + e3.osm_id + '">' + e3.display_name + "</option>";
      }, "");
    }).catch(function(t3) {
      return n2.fire(t3);
    });
  }, lookup: function(t2) {
    var e2 = this, n2 = this.constructUrl(this.url + "reverse", { format: "json", osm_type: t2.charAt(0), osm_id: t2.slice(1) });
    this.fetchJson(n2).then(function(t3) {
      return e2.mark(t3);
    }).catch(function(t3) {
      return e2.fire(t3);
    });
  }, geocode: function(t2) {
    var e2 = this;
    this.search(t2).then(function(t3) {
      if (t3.length < 1)
        throw "notfound";
      return t3[0];
    }).then(function(t3) {
      return e2.mark(t3);
    }).catch(function(t3) {
      return e2.fire(t3);
    });
  } }), L.geo.GeoNames = L.geo.Geocoder.extend({ url: "http://api.geonames.org/search", fetchGeonames: function(t2) {
    return this.fetchJson(t2).then(function(t3) {
      var e2 = t3.geonames;
      if (!e2 || e2.length < 1)
        throw "notfound";
      return e2;
    });
  }, mark: function(t2) {
    var e2 = L.latLng(t2.lat, t2.lng), n2 = t2.bbox, o2 = L.latLngBounds([n2.north, n2.west], [n2.south, n2.east]);
    this.placeMarker(e2, o2, t2);
  }, suggest: function(t2, e2) {
    var n2 = this, o2 = this.constructUrl(this.url, { q: t2, type: "json", style: "short" });
    this.fetchGeonames(o2).then(function(t3) {
      e2.innerHTML = t3.reduce(function(t4, e3) {
        return t4 + '<option data-id="' + e3.geonameId + '">' + e3.name + "&emsp;" + e3.countryCode + "</option>";
      }, "");
    }).catch(function(t3) {
      return n2.fire(t3);
    });
  }, lookup: function(t2) {
    var e2 = this, n2 = this.constructUrl("http://api.geonames.org/getJSON", { geonameId: t2 });
    this.fetchJson(n2).then(function(t3) {
      return e2.mark(t3);
    }).catch(function(t3) {
      return e2.fire(t3);
    });
  }, geocode: function(t2) {
    var e2 = this, n2 = this.constructUrl(this.url, { q: t2, inclBbox: true });
    this.fetchGeonames(n2).then(function(t3) {
      return t3.shift();
    }).then(function(t3) {
      return e2.mark(t3);
    }).catch(function(t3) {
      return e2.fire(t3);
    });
  } }), L.geo.Here = L.geo.Geocoder.extend({ mark: function(t2) {
    var e2 = t2.displayPosition, n2 = L.latLng(e2.latitude, e2.longitude), o2 = t2.mapView, r2 = o2.topLeft, i2 = o2.bottomRight, s2 = L.latLngBounds([r2.latitude, i2.longitude], [i2.latitude, r2.longitude]);
    this.placeMarker(n2, s2, t2);
  }, fetchData: function(t2) {
    var e2 = this;
    t2.jsonattributes = 1;
    var n2 = this.constructUrl("https://geocoder.ls.hereapi.com/6.2/geocode.json", t2);
    this.fetchJson(n2).then(function(t3) {
      return t3.response.view.shift().result.shift();
    }).then(function(t3) {
      return e2.mark(t3.location);
    }).catch(function(t3) {
      return e2.fire(t3);
    });
  }, suggest: function(t2, e2) {
    var n2 = this, o2 = this.constructUrl("https://autocomplete.geocoder.ls.hereapi.com/6.2/suggest.json", { query: t2 });
    this.fetchJson(o2).then(function(t3) {
      return t3.suggestions;
    }).then(function(t3) {
      e2.innerHTML = t3.reduce(function(t4, e3) {
        return t4 + '<option data-id="' + e3.locationId + '">' + e3.label + "</option>";
      }, "");
    }).catch(function(t3) {
      return n2.fire(t3);
    });
  }, lookup: function(t2) {
    this.fetchData({ locationid: t2 });
  }, geocode: function(t2) {
    this.fetchData({ searchtext: t2 });
  } }), L.geo.TomTom = L.geo.Geocoder.extend({ url: "https://api.tomtom.com/search/2/geocode/", suggestions: [], datalist: null, mark: function(t2) {
    var e2 = t2.position, n2 = L.latLng(e2.lat, e2.lon), o2 = t2.viewport, r2 = o2.topLeftPoint, i2 = o2.btmRightPoint, s2 = L.latLngBounds([r2.lat, i2.lon], [i2.lat, r2.lon]);
    this.placeMarker(n2, s2, t2);
  }, fetchResults: function(t2, e2) {
    void 0 === e2 && (e2 = {});
    var n2 = encodeURIComponent(t2), o2 = this.constructUrl("" + this.url + n2 + ".json", e2);
    return this.fetchJson(o2).then(function(t3) {
      if (t3.summary.numResults < 1)
        throw "notfound";
      return t3.results;
    });
  }, suggest: function(t2, e2) {
    var n2 = this;
    this.datalist = e2, this.fetchResults(t2, { typeahead: true }).then(function(t3) {
      n2.suggestions = t3, e2.innerHTML = t3.reduce(function(t4, e3) {
        return t4 + '<option data-id="' + e3.id + '">' + e3.address.freeformAddress + "</option>";
      }, "");
    }).catch(function(t3) {
      return n2.fire(t3);
    });
  }, lookup: function(t2) {
    var e2 = this.suggestions.find(function(e3) {
      return e3.id === t2;
    });
    e2 && this.mark(e2);
  }, geocode: function(t2) {
    var e2 = this;
    this.fetchResults(t2).then(function(t3) {
      return t3.shift();
    }).then(function(t3) {
      return e2.mark(t3);
    }).catch(function(t3) {
      return e2.fire(t3);
    });
  } }), L.geo.Kadaster = L.geo.Geocoder.extend({ url: "https://geodata.nationaalgeoregister.nl/locatieserver/v3/", mark: function(t2) {
    this.placeMarker(t2.centroide_ll.match(/[\d.]+/g).reverse(), null, t2);
  }, suggest: function(t2, e2) {
    var n2 = this, o2 = this.constructUrl(this.url + "suggest", { q: t2 + " and -type:postcode" });
    this.fetchJson(o2).then(function(t3) {
      if (t3.response.numFound < 1)
        throw "notfound";
      return t3.highlighting;
    }).then(function(t3) {
      var n3 = "";
      for (var o3 in t3) {
        n3 += '<option data-id="' + o3 + '">' + t3[o3].suggest.shift() + "</option>";
      }
      e2.innerHTML = n3;
    }).catch(function(t3) {
      return n2.fire(t3);
    });
  }, lookup: function(t2) {
    var e2 = this, n2 = this.constructUrl(this.url + "lookup", { id: t2 });
    this.fetchJson(n2).then(function(t3) {
      return t3.response.docs.shift();
    }).then(function(t3) {
      return e2.mark(t3);
    }).catch(function(t3) {
      return e2.fire(t3);
    });
  }, geocode: function(t2) {
    var e2 = this, n2 = this.constructUrl(this.url + "free", { q: t2 + " and -type:postcode" });
    this.fetchJson(n2).then(function(t3) {
      if (t3.response.numFound < 1)
        throw "notfound";
      return t3.response.docs.shift();
    }).then(function(t3) {
      return e2.mark(t3);
    }).catch(function(t3) {
      return e2.fire(t3);
    });
  } });
  var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, e = /^\s+|\s+$/g, n = /^[-+]0x[0-9a-f]+$/i, o = /^0b[01]+$/i, r = /^0o[0-7]+$/i, i = parseInt, s = "object" == typeof t && t && t.Object === Object && t, u = "object" == typeof self && self && self.Object === Object && self, c = s || u || Function("return this")(), a = Object.prototype.toString, h = Math.max, f = Math.min, l = function() {
    return c.Date.now();
  };
  function d(t2) {
    var e2 = typeof t2;
    return !!t2 && ("object" == e2 || "function" == e2);
  }
  function g(t2) {
    if ("number" == typeof t2)
      return t2;
    if (function(t3) {
      return "symbol" == typeof t3 || function(t4) {
        return !!t4 && "object" == typeof t4;
      }(t3) && "[object Symbol]" == a.call(t3);
    }(t2))
      return NaN;
    if (d(t2)) {
      var s2 = "function" == typeof t2.valueOf ? t2.valueOf() : t2;
      t2 = d(s2) ? s2 + "" : s2;
    }
    if ("string" != typeof t2)
      return 0 === t2 ? t2 : +t2;
    t2 = t2.replace(e, "");
    var u2 = o.test(t2);
    return u2 || r.test(t2) ? i(t2.slice(2), u2 ? 2 : 8) : n.test(t2) ? NaN : +t2;
  }
  var p = function(t2, e2, n2) {
    var o2, r2, i2, s2, u2, c2, a2 = 0, p2 = false, m = false, v = true;
    if ("function" != typeof t2)
      throw new TypeError("Expected a function");
    function L2(e3) {
      var n3 = o2, i3 = r2;
      return o2 = r2 = void 0, a2 = e3, s2 = t2.apply(i3, n3);
    }
    function b(t3) {
      return a2 = t3, u2 = setTimeout(x, e2), p2 ? L2(t3) : s2;
    }
    function k(t3) {
      var n3 = t3 - c2;
      return void 0 === c2 || n3 >= e2 || n3 < 0 || m && t3 - a2 >= i2;
    }
    function x() {
      var t3 = l();
      if (k(t3))
        return y(t3);
      u2 = setTimeout(x, function(t4) {
        var n3 = e2 - (t4 - c2);
        return m ? f(n3, i2 - (t4 - a2)) : n3;
      }(t3));
    }
    function y(t3) {
      return u2 = void 0, v && o2 ? L2(t3) : (o2 = r2 = void 0, s2);
    }
    function w() {
      var t3 = l(), n3 = k(t3);
      if (o2 = arguments, r2 = this, c2 = t3, n3) {
        if (void 0 === u2)
          return b(c2);
        if (m)
          return u2 = setTimeout(x, e2), L2(c2);
      }
      return void 0 === u2 && (u2 = setTimeout(x, e2)), s2;
    }
    return e2 = g(e2) || 0, d(n2) && (p2 = !!n2.leading, i2 = (m = "maxWait" in n2) ? h(g(n2.maxWait) || 0, e2) : i2, v = "trailing" in n2 ? !!n2.trailing : v), w.cancel = function() {
      void 0 !== u2 && clearTimeout(u2), a2 = 0, o2 = c2 = r2 = u2 = void 0;
    }, w.flush = function() {
      return void 0 === u2 ? s2 : y(l());
    }, w;
  };
  L.Control.Search = L.Control.extend({ initialize: function(t2) {
    L.setOptions(this, L.extend({ debounce: 300, suggest: 2 }, t2));
  }, onAdd: function(t2) {
    var e2 = t2.getContainer().id + "_dl", n2 = L.DomUtil.create("div", "geo-search"), o2 = L.DomUtil.create("input", null, n2);
    o2.type = "text", o2.setAttribute("list", e2), L.DomEvent.on(o2, "input", p(function(e3) {
      e3.target.value.length >= this.options.suggest && t2._geocoder.suggest(e3.target.value, i2);
    }, this.options.debounce), this), L.DomEvent.on(o2, "change", function(t3) {
      var e3 = t3.target.value, o3 = i2.childNodes;
      t3.target.value = "", n2.classList.remove("open");
      for (var r3 = 0; r3 < o3.length; r3++)
        if (e3.startsWith(o3[r3].innerText))
          return void this._geocoder.lookup(o3[r3].dataset.id);
      this.geocode(e3);
    }, t2);
    var r2 = L.DomUtil.create("button", null, n2);
    r2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>', r2.title = "Search", L.DomEvent.on(r2, "click", function(t3) {
      t3.preventDefault(), t3.stopPropagation(), this.toggle();
    }, this);
    var i2 = L.DomUtil.create("datalist", null, n2);
    return i2.id = e2, n2;
  }, toggle: function() {
    var t2 = this.getContainer(), e2 = t2.classList, n2 = e2.contains("open");
    e2.toggle("open"), n2 || t2.children[0].focus();
  } }), L.control.search = function(t2) {
    return new L.Control.Search(t2);
  }, L.Map.include({ marker: null, placeMarker: function(t2, e2, n2) {
    if (this.fire("geofound", { latlng: t2, bbox: e2, place: n2 }), this.marker)
      this.marker.setLatLng(t2);
    else {
      var o2 = this.options.createMarker || L.marker;
      this.marker = o2(t2).addTo(this);
    }
    this.options.fly ? e2 ? this.flyToBounds(e2) : this.flyTo(t2) : e2 ? this.fitBounds(e2) : this.panTo(t2);
  }, geocode: function(t2) {
    return this._geocoder.geocode(t2), this;
  }, setGeocoder: function(t2, e2) {
    return void 0 === e2 && (e2 = {}), this._geocoder = new L.geo[t2](this, e2), this;
  } }), L.Map.addInitHook(function() {
    this.setGeocoder("Nominatim", {});
  });
}();
/*! Bundled license information:

@sjaakp/leaflet-search/dist/leaflet-search.js:
  (*!
   * LeafletSearch 1.0.1
   * (c) 2020 Sjaak Priester, Amsterdam
   * MIT License
   * https://github.com/sjaakp/leaflet-search
   * https://sjaakpriester.nl
   *)
*/
//# sourceMappingURL=@sjaakp_leaflet-search_dist_leaflet-search.js.map
